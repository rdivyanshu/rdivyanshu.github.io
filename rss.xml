<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
 <title>Blogs</title>
 <link>https://rdivyanshu.github.io</link>
 <description>Divyanshu Ranjan's blog</description>
 <lastBuildDate>2024-06-03T19:42:53+05:30</lastBuildDate>
 <pubDate>2024-06-03T19:42:53+05:30</pubDate>
 <ttl>1800</ttl>
 <item>
  <title>A Formalization in Lean</title>
  <description><![CDATA[<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>A Formalization in Lean</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h3 id="problem">Problem</h3>
<p>Consider the following problem.</p>
<p><img src="https://rdivyanshu.github.io/img/OC588.png" /></p>
<p>Its solution is published in <a
href="https://cms.math.ca/publications/crux/issue/?volume=49&amp;issue=1">Crux
Volume 49, Issue 1</a>.</p>
<h3 id="formalization">Formalization</h3>
<p>Here is Lean formalization of it.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>import Mathlib.Algebra.Ring.Defs</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>import Mathlib.Data.Finite.Defs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>import Mathlib.Data.Set.Finite</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>import Mathlib.Data.Nat.Lattice</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>theorem crux_oc588 {R: Type*} [Ring R] [Finite R]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    (a b : R) (h : (a * b - 1) * b = 0) : b * (a * b - 1) = 0 := by</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  let s := { b ^ k | k : ℕ }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  have h₁: s.Finite := by</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    exact Set.toFinite s</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  let t := { k | ∃ n, k &lt; n ∧ b ^ k = b ^ n }</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  have h₂: t.Nonempty := by</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    by_contra h₂</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    simp only [t, Set.Nonempty, Set.mem_setOf_eq, not_exists, not_and] at h₂</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    have h₃: s.Infinite := by</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      have ha: Function.Injective (fun x ↦ b ^ x) := by</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>       exact injective_of_lt_imp_ne h₂</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      have hb: ∀ k : ℕ, b ^ k ∈ s := by</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        refine fun k ↦ Set.mem_setOf.mpr ?_</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        use k</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>      exact Set.infinite_of_injective_forall_mem ha hb</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    exact h₃ h₁</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  have h₃: a * (b * b) = b := by</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    rw [sub_mul, one_mul, sub_eq_zero, mul_assoc] at h</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    exact h</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  by_cases hm₁: (sInf t = 0)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    rw [hm₁, pow_zero] at hn</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    have: b * a * b = b := by</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      rw [← mul_one b, hn.right, ← mul_assoc, </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>          (Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>          pow_add b 1 (n - 1), pow_one, ← mul_assoc]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      nth_rewrite 2 [mul_assoc, mul_assoc]</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>      rw [h₃, mul_assoc]</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>      nth_rewrite 2 [← pow_one b]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>      rw [← pow_add b 1 (n - 1), </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>          ← (Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>          ← hn.right, mul_one]</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    rw [mul_sub, ← mul_assoc, this, mul_one, sub_self]</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>  · by_cases hm₂: (sInf t = 1)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>      rw [hm₂, pow_one] at hn</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>      have: b * a * b = b := by</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        nth_rewrite 2 [hn.right]</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        rw [(Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>            pow_add b 2 (n - 2), ← mul_assoc, pow_add b 1 1, pow_one]</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        nth_rewrite 2 [mul_assoc]</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        rw [h₃, ← pow_one b, ← pow_add b 1 1, pow_one b,</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            ← pow_add b 2 (n - 2), Nat.add_sub_of_le hn.left, ← hn.right]</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>      rw [mul_sub, ← mul_assoc, this, mul_one, sub_self]</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>      have hm₃: 2 ≤ sInf t := by</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        exact (Nat.two_le_iff (sInf t)).mpr { left := hm₁, right := hm₂ }</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>      have: b ^ (sInf t - 1) = b ^ (n - 1) := by</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        rw [(Nat.sub_eq_iff_eq_add&#39; (Nat.le_sub_one_of_lt hm₃)).mp rfl,</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>             pow_add b 1 (sInf t - 1 - 1), pow_one]</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        nth_rewrite 1 [← h₃]</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        rw [← pow_one b, ← pow_add b 1 1, pow_one b, mul_assoc, </span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>            ← pow_add b 2 (sInf t - 1 - 1),</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            ← (Nat.sub_eq_iff_eq_add&#39; hm₃).mp, hn.right]</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        have: 2 &lt; n := by</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>          exact (LE.le.trans_lt hm₃ hn.left)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        nth_rewrite 1 </span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>          [(Nat.sub_eq_iff_eq_add&#39; (Nat.lt_succ.mp (Nat.le.step this))).mp rfl]</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        · rw [pow_add b 2 (n - 2), pow_add b 1 1, pow_one, ← mul_assoc, h₃]</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>          nth_rewrite 1 [← pow_one b]</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>          rw [← pow_add b 1 (n - 2), </span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>              ← (@Nat.sub_eq_iff_eq_add&#39; 1 (n - 1) (n - 2) ?_).mp rfl]</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>          exact Nat.le_sub_one_of_lt (Nat.lt_trans Nat.le.refl this)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        · rfl</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>      have: (sInf t - 1) ∈ t := by</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>        refine Set.mem_setOf.mpr ?_</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        use n - 1</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        constructor</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        · exact (tsub_lt_tsub_iff_right (Nat.one_le_of_lt hm₃)).mpr hn.left</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        · exact this</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>      have: sInf t ≤ (sInf t - 1) := by exact Nat.sInf_le this</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>      exact absurd (Nat.sub_one_lt_of_le (Nat.zero_lt_of_lt hm₃) Nat.le.refl)</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>                   (not_lt_of_le this)</span></code></pre></div>
</body>
</html>]]></description>
 </item>
 <item>
  <title>Verifying using temporal logic of action in Dafny </title>
  <description><![CDATA[<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Verifying using temporal logic of action in Dafny</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>In <a
href="https://rdivyanshu.github.io/posts/2023/08/stuttering-steps-in-tla.html">previous
blog</a> we looked into why TLA+ specification enforces SI (stuttering
insensitivity) and how verifying liveness assertion required us to add
fairness condition in spec. In this blog we will model timer displaying
minute in Dafny using temporal logic of action. And then we will prove
that specifiction, with fairness condition included, implies that timer
will eventually reach 0 (In previous blog we model checked this
property).</p>
<p>First order of bussiness is encode state of our system, specify what
it is correct initial state and how system moves from one state to
another. We need to be mindful that our action satistifes stuttering
insensitivity requirement of temporal logic of action. Formally step
<code>st</code> is enabled in state <code>s</code> if there exists state
<code>e</code> such that <code>st(s, e)</code> is true. There is easlier
way to say so for DecreaseMin step that is min is greater than 0.</p>
<pre class="dafny"><code>datatype State = State(min: int)

predicate Init(s: State){
  s.min == 5
}

predicate EnabledDecreaseMin(s: State){
  s.min &gt; 0
}

predicate DecreaseMin(s: State, t: State){
  EnabledDecreaseMin(s) &amp;&amp; s.min - 1 == t.min
}

predicate Stutter(s: State, t: State){
  s.min == t.min
}

predicate Next(s: State, t: State){
  DecreaseMin(s, t) || Stutter(s, t)
}</code></pre>
<p>TLA+ avoids explicit mention of index of state in behavior. In Dafny
we will be using infinite map <code>imap</code> to model behavior where
value at key <code>n</code> is <code>nth</code> state. That is why we
have additional requirement in spec that every natural number exists in
map. Next we want DecreaseMin step to be weakly fair. I am using
definition from Chapter 8 of Specifying Systems where it is defined to
be <code>[]([](Enabled &lt;A&gt;_v) =&gt; &lt;&gt;&lt;A&gt;_v)</code>.
Step <code>st</code> is weakly fair if <code>st</code> is enabled
forever then eventually <code>st</code> will happen. There are alternate
ways to say step is weakly fair, equivalent to this definition. Some
triggers are mentioned in code below which helps SMT solvers to use
quantifiers in guided manner but can be ignored for this discussion.</p>
<pre class="dafny"><code>function Increase(i: nat): nat {
  i+1
}

ghost predicate WeakFairness(t: imap&lt;nat, State&gt;)
  requires forall i : nat :: i in t
{
   forall i: nat {:trigger EnabledDecreaseMin(t[i])} :: (
      (forall j: nat :: j &gt;= i ==&gt; EnabledDecreaseMin(t[j]))
      ==&gt;
      (exists k: nat :: k &gt;= i &amp;&amp; DecreaseMin(t[k], t[Increase(k)]))
   )
}

function Identity(n: nat) : nat {
  n
}

ghost predicate Spec(t: imap&lt;nat, State&gt;){
   (forall i : nat :: i in t)
 &amp;&amp; Init(t[0])
 &amp;&amp; (forall i : nat {:trigger Identity(i)}:: Next(t[i], t[i+1]))
 &amp;&amp; WeakFairness(t)
}</code></pre>
<p>We need two safety properties to prove liveness property. First is
<code>min</code> is always greater than or equal to 0. And second is
<code>min</code> is non increasing in behavior. I have omitted proof but
it can be seen <a
href="https://gist.github.com/rdivyanshu/f2b0a03c6ceeb7659ec6bf9db91e3c86">here</a>.</p>
<pre class="dafny"><code>lemma Safety(t: imap&lt;nat, State&gt;, k: nat)
  requires Spec(t)
  ensures t[k].min &gt;= 0


lemma SafetyDecreasing(t: imap&lt;nat, State&gt;, m: nat, n: nat)
  requires Spec(t)
  requires m &lt;= n
  ensures t[m].min &gt;= t[n].min</code></pre>
<p>To prove that timer will eventually reach 0 we start with initial
state and try to convince Dafny that we can always find state
<code>m</code> (I am using index of state as synonyms for that state) in
which <code>min</code> is 0. There are two cases to consider a) when
antecedent of weak fairness is true and b) when it is false. In second
case antecedant being false means there exists state <code>k</code> at
which <code>min</code> is less than or equal to 0 which together with
safety condition proves that <code>min</code> is exactly 0. In first
case applying antecedent to weakly fair property gives us state
<code>k</code> at which next transition will decreases <code>min</code>.
Note that it just says that <code>min</code> will decrease between state
<code>k</code> and <code>k+1</code>. It is required that current state
<code>r</code> has <code>min</code> value greater than or equal to
<code>min</code> of state <code>k</code> to prove that <code>min</code>
actually decreases during our search. This is done using safety property
<code>SafetyDecreasing</code>. Since <code>min</code> is finite positive
number applying this argument again and again we will reach state
<code>m</code> where <code>min</code> is 0.</p>
<pre class="dafny"><code>lemma ExistsHelperLemma(t: imap&lt;nat, State&gt;, m: nat)
  requires forall i : nat :: i in t
  requires !(forall j : nat :: j &gt;= m ==&gt; EnabledDecreaseMin(t[j]))
  ensures exists k : nat :: k &gt;= m &amp;&amp; !EnabledDecreaseMin(t[k])
{}

lemma Eventually(t: imap&lt;nat, State&gt;)
  requires Spec(t)
  ensures exists m : nat :: t[m].min == 0
{
   var r : nat := 0;
   while t[r].min &gt; 0
    invariant t[r].min &gt;= 0
    decreases t[r].min
   {
     if(forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j])) {
        assert exists k: nat :: k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]) by {
          assert r == Identity(r);
          assert EnabledDecreaseMin(t[r]);
          assert
            (forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j])) ==&gt;
            (exists k: nat :: k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]));
        }
        var k :| k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]);
        assert Increase(k) == k + 1;
        SafetyDecreasing(t, r, k);
        assert t[r].min &gt;= t[k].min;
        assert t[k+1].min == t[k].min - 1;
        assert t[r].min &gt;= t[k].min &gt; t[k+1].min;
        r := k + 1;
        if t[r].min == 0 { return; }
     }
     else {
        assert !(forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j]));
        ExistsHelperLemma(t, r);
        var k :| k &gt;= r &amp;&amp; !EnabledDecreaseMin(t[k]);
        assert t[k].min &lt;= 0;
        Safety(t, k);
        return;
     }
   }
}</code></pre>
<p>There is alternate way to think about this proof. When does timer
will never reach state where <code>min</code> is 0 assuming safety part
of spec (<code>Init</code> and <code>Next</code>) ? It is when timer
stops working when <code>min</code> is displaying some number greater
than 0 - behavior stutters infinitely afterwards. Does our spec include
such behavior? In this behavior weakly fair condition allows us to find
sequence of states in which <code>min</code> is decreasing to 0. But
this is contradiction. Hence such behavior is not statisfied by our
Spec.</p>
<p>This is rather silly example to show temporal logic argument - there
is no two or more processes/servers competing for fair execution. But I
hope this small example which is written in programming language like
syntax shows how such argument works.</p>
</body>
</html>]]></description>
 </item>
 <item>
  <title>Uncovering ghouls using Answer Set Programming</title>
  <description><![CDATA[<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Uncovering ghouls using Answer Set Programming</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Recently I came across this nice puzzle - <a
href="https://krazydad.com/haunted/">Haunted</a>. These days my impulse
when presented with puzzle is throw Answer Set Programming on it. To get
idea of ASP follow <a
href="https://rdivyanshu.github.io/posts/2023/07/solving-hitori-using-clingo.html">this
blog</a> which solves another puzzle which has somewhat straightforward
encoding in ASP.</p>
<p><img src="https://rdivyanshu.github.io/img/haunted.png" /></p>
<p>A sample puzzle instance and its solution is shown above. In haunted
you have to figure out where ghouls (ghosts, zombies and draculas) are
hidding in rectangular grid. You can’t directly see ghosts but they are
visible in mirrors. Draculas conceal themselves in mirrors but otherwise
visible. Zombies have no such powers. You are also given count of each
ghoul types and how many of them are visible (counting multiplicity)
from boundary locations.</p>
<p>As per tradition, we encode instance and solution separately. First
up instance of above puzzle</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>#const n = 4.</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>count(0, 1, 0). count(0, 2, 2). count(0, 3, 2). count(0, 4, 3).</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>count(1, 0, 2). count(2, 0, 1). count(3, 0, 2). count(4, 0, 0).</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>count(5, 1, 1). count(5, 2, 1). count(5, 3, 1). count(5, 4, 2).</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>count(1, 5, 1). count(2, 5, 1). count(3, 5, 2). count(4, 5, 1).</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>mirror(1, 4, &quot;/&quot;).</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>mirror(2, 1, &quot;\&quot;). mirror(2, 4, &quot;/&quot;).</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>mirror(3, 2, &quot;/&quot;). mirror(3, 3, &quot;/&quot;).</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>mirror(4, 2, &quot;\&quot;). mirror(4, 3, &quot;\&quot;).</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>ghost(2). dracula(4). zombie(3).</span></code></pre></div>
<p>We declare size of grid as constant <code>n</code>.
<code>count(X, Y, N)</code> encodes relation that from <code>X</code>,
<code>Y</code> coordinate <code>N</code> number of ghouls are visible
(Grid has been extended to include <code>0</code>th and
<code>(n+1)</code>th row and column). <code>mirror(X, Y, T)</code>
states the fact that there is mirror of type <code>T</code> at location
<code>X</code>, <code>Y</code>. Finally number of each ghoul type is
mentioned.</p>
<p>Next general solution as described below. First statement describes
our grid. Next 3 statements place ghouls on grid. For example
<code>{ ghost(X, Y) : grid(X, Y) } = N :- ghost(N)</code> states that
each grid location is valid placement for ghost though solution should
only select as many as grid locations as there are ghosts. After this we
add constraints that ghouls and mirrors don’t occupy same place as well
as two different kind of ghouls.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>grid(X, Y) :- X = 1..n, Y = 1..n.</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>{ ghost(X, Y) : grid(X, Y) } = N :- ghost(N).</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>{ dracula(X, Y) : grid(X, Y) } = N :- dracula(N).</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>{ zombie(X, Y) : grid(X, Y) } = N :- zombie(N).</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>:- ghost(X, Y), mirror(X, Y, T).</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>:- dracula(X, Y), mirror(X, Y, T).</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>:- zombie(X, Y), mirror(X, Y, T).</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>:- ghost(X, Y), dracula(X, Y).</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>:- ghost(X, Y), zombie(X, Y).</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>:- dracula(X, Y), zombie(X, Y).</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>ghost(X, Y, N) :- count(X, Y, TN),</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>         N = #count { GX, GY, D : mirror_visible(X, Y, GX, GY, D), ghost(GX, GY) }.</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>dracula(X, Y, N) :- count(X, Y, TN),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>         N = #count { DX, DY, D : direct_visible(X, Y, DX, DY, D), dracula(DX, DY) }.</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>zombie(X, Y, N1 + N2) :- count(X, Y, TN),</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>         N1 = #count { ZX, ZY, D : mirror_visible(X, Y, ZX, ZY, D), zombie(ZX, ZY) },</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>         N2 = #count { ZX, ZY, D : direct_visible(X, Y, ZX, ZY, D), zombie(ZX, ZY) }.</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>:- count(X, Y, N), ghost(X, Y, G), dracula(X, Y, D), zombie(X, Y, Z), N != G + D + Z.</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>#show ghost/2.</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>#show dracula/2.</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>#show zombie/2.</span></code></pre></div>
<p><code>ghost(X, Y, N)</code> inscribes that <code>N</code> ghosts are
visible from boundary location <code>X</code>, <code>Y</code>.
<code>N</code> is equal to number of times we see ghosts in mirrors.
Aggregate form <code>#count</code> counts number of elements in a set.
In our case elements are tuple <code>GX</code>, <code>GY</code>,
<code>D</code> where <code>GX</code>, <code>GY</code> is location of
ghost which is visible from <code>X</code>, <code>Y</code>. We need
additional direction component <code>D</code> to account for multiple
views of same ghoul by mirror reflections. Last component of
<code>count/3</code> should be sum of last components of
<code>ghost/3</code>, <code>dracula/3</code> and <code>zombie/3</code>
as mentioned as constraint. Notice that clingo (ASP implementation we
are using) allows us to use same name for relations with different
arity. That’s why a relation is mentioned by its name and arity like
<code>ghost/2</code> in show directive.</p>
<p>We haven’t defined <code>mirror_visible</code> and
<code>direct_visible</code> relations yet. It might be possible to
declare such relation in ASP declarative language, but I found it
cumbersome to do so and used it as opportunity to learn about clingo
python scripting facility documented <a
href="https://potassco.org/clingo/python-api/5.6/">here</a>.</p>
<p>We proceed in steps. First let us read instance file, store each
statement in an array besides adding it to program we are currently
evaluating.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>statements = []</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>clingo.ast.parse_string(</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>   open(&quot;instance.lp&quot;).read(),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>   lambda st: statements.append(st)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>with clingo.ast.ProgramBuilder(ctl) as b:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>   for st in statements:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      b.add(st)</span></code></pre></div>
<p>Next we will find location of mirrors in grid by going through each
rule and checking if its head starts with <code>mirror</code>. If it is
we will store arguments in <code>mirror_loc</code> - its location and
type.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mirror_loc = []</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>for st in statements:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   if st.ast_type != clingo.ast.ASTType.Rule:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      continue</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   ast_dict = clingox.ast.ast_to_dict(st)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>   if ast_dict[&quot;head&quot;][&quot;atom&quot;][&quot;symbol&quot;][&quot;name&quot;] != &quot;mirror&quot;:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      continue</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   arguments = ast_dict[&quot;head&quot;][&quot;atom&quot;][&quot;symbol&quot;][&quot;arguments&quot;]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>   arguments = map(lambda x: clingox.ast.dict_to_ast(x), arguments)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>   r, c, t = map(lambda x: dict(x.items())[&quot;symbol&quot;], arguments)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>   mirror_loc.append(((r.number, c.number), t.string))</span></code></pre></div>
<p>For each boundary location we trace path of light as it bounces off
through mirrors storing which grid location it arrives at via mirrors
and which directly. Then we add appropriate relation -
<code>direct_visible</code> or <code>mirror_visible</code>. When finding
out mirror location we have to deconstruct clingo AST, here we have to
construct clingo AST which is done using <code>build_rule_ast</code>
function.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>lookouts = itertools.chain.from_iterable(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   [[(0, i), (n+1, i), (i, 0), (i, n+1)] for i in range(1, n+1)])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>for i, j in lookouts:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>   direct, mirror = visibility(n, i, j, dict(mirror_loc))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>   with clingo.ast.ProgramBuilder(ctl) as b:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      for (r, c, d) in direct:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>         b.add(build_rule_ast(</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                &quot;direct_visible&quot;,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                [clingo.symbol.Number(i), clingo.symbol.Number(j),</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                 clingo.symbol.Number(r), clingo.symbol.Number(c),</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                 clingo.symbol.String(d)]))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>      for (r, c, d) in mirror:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>         b.add(build_rule_ast(</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                &quot;mirror_visible&quot;,</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                [clingo.symbol.Number(i), clingo.symbol.Number(j),</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                 clingo.symbol.Number(r), clingo.symbol.Number(c),</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                 clingo.symbol.String(d)]))</span></code></pre></div>
<p>Let’s finally run our <a
href="https://gist.github.com/rdivyanshu/ea7d280767c7c68cffb94f1421813efa">program</a>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a># clingo solution.lp</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>clingo version 5.6.2</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>Reading from solution.lp</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>Solving...</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Answer: 1</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>zombie(1,2) zombie(1,3) zombie(4,4) dracula(2,2) dracula(2,3) dracula(3,1) </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>dracula(3,4) ghost(1,1) ghost(4,1)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>SATISFIABLE</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>Models       : 1+</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>Calls        : 1</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>Time         : 0.071s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>CPU Time     : 0.071s</span></code></pre></div>
</body>
</html>]]></description>
 </item>
</channel>
</rss>
