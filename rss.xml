<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title>Blogs (rdivyanshu)</title>
<link>https://rdivyanshu.github.io</link>
<description>Posts from rdivyanshu.github.io</description>
<language>en-US</language>
<webMaster>webmaster@rdivyanshu.github.io (Divyanshu Ranjan)</webMaster>
<docs>https://www.rssboard.org/rss-specification</docs>
<generator>pandoc-rss</generator>
<item>
<title>A Formalization in Lean</title>
<guid>https://rdivyanshu.github.io/lean.html</guid>
<description><![CDATA[<p><a href="index.html">↫ Home</a></p>
<h1 id="a-formalization-in-lean">A Formalization in Lean</h1>
<h3 id="problem">Problem</h3>
<p>Consider the following problem.</p>
<p><img src="https://rdivyanshu.github.io/OC588.png" /></p>
<p>Its solution is published in <a href="https://cms.math.ca/publications/crux/issue/?volume=49&amp;issue=1">Crux Volume 49, Issue 1</a>.</p>
<h3 id="formalization">Formalization</h3>
<p>Here is Lean formalization of it.</p>
<pre><code>import Mathlib.Algebra.Ring.Defs
import Mathlib.Data.Finite.Defs
import Mathlib.Data.Set.Finite
import Mathlib.Data.Nat.Lattice

theorem crux_oc588 {R: Type*} [Ring R] [Finite R]
    (a b : R) (h : (a * b - 1) * b = 0) : b * (a * b - 1) = 0 := by

  let s := { b ^ k | k : ℕ }
  have h₁: s.Finite := by
    exact Set.toFinite s

  let t := { k | ∃ n, k &lt; n ∧ b ^ k = b ^ n }
  have h₂: t.Nonempty := by
    by_contra h₂
    simp only [t, Set.Nonempty, Set.mem_setOf_eq, not_exists, not_and] at h₂
    have h₃: s.Infinite := by
      have ha: Function.Injective (fun x ↦ b ^ x) := by
       exact injective_of_lt_imp_ne h₂
      have hb: ∀ k : ℕ, b ^ k ∈ s := by
        refine fun k ↦ Set.mem_setOf.mpr ?_
        use k
      exact Set.infinite_of_injective_forall_mem ha hb
    exact h₃ h₁

  have h₃: a * (b * b) = b := by
    rw [sub_mul, one_mul, sub_eq_zero, mul_assoc] at h
    exact h

  by_cases hm₁: (sInf t = 0)
  · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂
    rw [hm₁, pow_zero] at hn
    have: b * a * b = b := by
      rw [← mul_one b, hn.right, ← mul_assoc, 
          (Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,
          pow_add b 1 (n - 1), pow_one, ← mul_assoc]
      nth_rewrite 2 [mul_assoc, mul_assoc]
      rw [h₃, mul_assoc]
      nth_rewrite 2 [← pow_one b]
      rw [← pow_add b 1 (n - 1), 
          ← (Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,
          ← hn.right, mul_one]
    rw [mul_sub, ← mul_assoc, this, mul_one, sub_self]

  · by_cases hm₂: (sInf t = 1)
    · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂
      rw [hm₂, pow_one] at hn
      have: b * a * b = b := by
        nth_rewrite 2 [hn.right]
        rw [(Nat.sub_eq_iff_eq_add&#39; hn.left).mp rfl,
            pow_add b 2 (n - 2), ← mul_assoc, pow_add b 1 1, pow_one]
        nth_rewrite 2 [mul_assoc]
        rw [h₃, ← pow_one b, ← pow_add b 1 1, pow_one b,
            ← pow_add b 2 (n - 2), Nat.add_sub_of_le hn.left, ← hn.right]
      rw [mul_sub, ← mul_assoc, this, mul_one, sub_self]

    · obtain ⟨n, hn⟩ := Nat.sInf_mem h₂
      have hm₃: 2 ≤ sInf t := by
        exact (Nat.two_le_iff (sInf t)).mpr { left := hm₁, right := hm₂ }

      have: b ^ (sInf t - 1) = b ^ (n - 1) := by
        rw [(Nat.sub_eq_iff_eq_add&#39; (Nat.le_sub_one_of_lt hm₃)).mp rfl,
             pow_add b 1 (sInf t - 1 - 1), pow_one]
        nth_rewrite 1 [← h₃]
        rw [← pow_one b, ← pow_add b 1 1, pow_one b, mul_assoc, 
            ← pow_add b 2 (sInf t - 1 - 1),
            ← (Nat.sub_eq_iff_eq_add&#39; hm₃).mp, hn.right]
        have: 2 &lt; n := by
          exact (LE.le.trans_lt hm₃ hn.left)
        nth_rewrite 1 
          [(Nat.sub_eq_iff_eq_add&#39; (Nat.lt_succ.mp (Nat.le.step this))).mp rfl]
        · rw [pow_add b 2 (n - 2), pow_add b 1 1, pow_one, ← mul_assoc, h₃]
          nth_rewrite 1 [← pow_one b]
          rw [← pow_add b 1 (n - 2), 
              ← (@Nat.sub_eq_iff_eq_add&#39; 1 (n - 1) (n - 2) ?_).mp rfl]
          exact Nat.le_sub_one_of_lt (Nat.lt_trans Nat.le.refl this)
        · rfl

      have: (sInf t - 1) ∈ t := by
        refine Set.mem_setOf.mpr ?_
        use n - 1
        constructor
        · exact (tsub_lt_tsub_iff_right (Nat.one_le_of_lt hm₃)).mpr hn.left
        · exact this

      have: sInf t ≤ (sInf t - 1) := by exact Nat.sInf_le this
      exact absurd (Nat.sub_one_lt_of_le (Nat.zero_lt_of_lt hm₃) Nat.le.refl)
                   (not_lt_of_le this)</code></pre>]]></description>
</item>
<item>
<title>Verifying using temporal logic of action in Dafny</title>
<guid>https://rdivyanshu.github.io/tla-logic-in-dafny.html</guid>
<description><![CDATA[<p><a href="index.html">↫ Home</a></p>
<h1 id="verifying-using-temporal-logic-of-action-in-dafny">Verifying using temporal logic of action in Dafny</h1>
<p>In <a href="https://rdivyanshu.github.io/temporal.html">previous blog</a> we looked into why TLA+ specification enforces SI (stuttering insensitivity) and how verifying liveness assertion required us to add fairness condition in spec. In this blog we will model timer displaying minute in Dafny using temporal logic of action. And then we will prove that specifiction, with fairness condition included, implies that timer will eventually reach 0 (In previous blog we model checked this property).</p>
<p>First order of bussiness is encode state of our system, specify what it is correct initial state and how system moves from one state to another. We need to be mindful that our action satistifes stuttering insensitivity requirement of temporal logic of action. Formally step <code>st</code> is enabled in state <code>s</code> if there exists state <code>e</code> such that <code>st(s, e)</code> is true. There is easlier way to say so for DecreaseMin step that is min is greater than 0.</p>
<pre><code>datatype State = State(min: int)

predicate Init(s: State){
  s.min == 5
}

predicate EnabledDecreaseMin(s: State){
  s.min &gt; 0
}

predicate DecreaseMin(s: State, t: State){
  EnabledDecreaseMin(s) &amp;&amp; s.min - 1 == t.min
}

predicate Stutter(s: State, t: State){
  s.min == t.min
}

predicate Next(s: State, t: State){
  DecreaseMin(s, t) || Stutter(s, t)
}</code></pre>
<p>TLA+ avoids explicit mention of index of state in behavior. In Dafny we will be using infinite map <code>imap</code> to model behavior where value at key <code>n</code> is <code>nth</code> state. That is why we have additional requirement in spec that every natural number exists in map. Next we want DecreaseMin step to be weakly fair. I am using definition from Chapter 8 of Specifying Systems where it is defined to be <code>[]([](Enabled &lt;A&gt;_v) =&gt; &lt;&gt;&lt;A&gt;_v)</code>. Step <code>st</code> is weakly fair if <code>st</code> is enabled forever then eventually <code>st</code> will happen. There are alternate ways to say step is weakly fair, equivalent to this definition. Some triggers are mentioned in code below which helps SMT solvers to use quantifiers in guided manner but can be ignored for this discussion.</p>
<pre><code>function Increase(i: nat): nat {
  i+1
}

ghost predicate WeakFairness(t: imap&lt;nat, State&gt;)
  requires forall i : nat :: i in t
{
   forall i: nat {:trigger EnabledDecreaseMin(t[i])} :: (
      (forall j: nat :: j &gt;= i ==&gt; EnabledDecreaseMin(t[j]))
      ==&gt;
      (exists k: nat :: k &gt;= i &amp;&amp; DecreaseMin(t[k], t[Increase(k)]))
   )
}

function Identity(n: nat) : nat {
  n
}

ghost predicate Spec(t: imap&lt;nat, State&gt;){
   (forall i : nat :: i in t)
 &amp;&amp; Init(t[0])
 &amp;&amp; (forall i : nat {:trigger Identity(i)}:: Next(t[i], t[i+1]))
 &amp;&amp; WeakFairness(t)
}</code></pre>
<p>We need two safety properties to prove liveness property. First is <code>min</code> is always greater than or equal to 0. And second is <code>min</code> is non increasing in behavior. I have omitted proof but it can be seen <a href="https://gist.github.com/rdivyanshu/f2b0a03c6ceeb7659ec6bf9db91e3c86">here</a>.</p>
<pre><code>lemma Safety(t: imap&lt;nat, State&gt;, k: nat)
  requires Spec(t)
  ensures t[k].min &gt;= 0


lemma SafetyDecreasing(t: imap&lt;nat, State&gt;, m: nat, n: nat)
  requires Spec(t)
  requires m &lt;= n
  ensures t[m].min &gt;= t[n].min</code></pre>
<p>To prove that timer will eventually reach 0 we start with initial state and try to convince Dafny that we can always find state <code>m</code> (I am using index of state as synonyms for that state) in which <code>min</code> is 0. There are two cases to consider a) when antecedent of weak fairness is true and b) when it is false. In second case antecedant being false means there exists state <code>k</code> at which <code>min</code> is less than or equal to 0 which together with safety condition proves that <code>min</code> is exactly 0. In first case applying antecedent to weakly fair property gives us state <code>k</code> at which next transition will decreases <code>min</code>. Note that it just says that <code>min</code> will decrease between state <code>k</code> and <code>k+1</code>. It is required that current state <code>r</code> has <code>min</code> value greater than or equal to <code>min</code> of state <code>k</code> to prove that <code>min</code> actually decreases during our search. This is done using safety property <code>SafetyDecreasing</code>. Since <code>min</code> is finite positive number applying this argument again and again we will reach state <code>m</code> where <code>min</code> is 0.</p>
<pre><code>lemma ExistsHelperLemma(t: imap&lt;nat, State&gt;, m: nat)
  requires forall i : nat :: i in t
  requires !(forall j : nat :: j &gt;= m ==&gt; EnabledDecreaseMin(t[j]))
  ensures exists k : nat :: k &gt;= m &amp;&amp; !EnabledDecreaseMin(t[k])
{}

lemma Eventually(t: imap&lt;nat, State&gt;)
  requires Spec(t)
  ensures exists m : nat :: t[m].min == 0
{
   var r : nat := 0;
   while t[r].min &gt; 0
    invariant t[r].min &gt;= 0
    decreases t[r].min
   {
     if(forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j])) {
        assert exists k: nat :: k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]) by {
          assert r == Identity(r);
          assert EnabledDecreaseMin(t[r]);
          assert
            (forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j])) ==&gt;
            (exists k: nat :: k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]));
        }
        var k :| k &gt;= r &amp;&amp; DecreaseMin(t[k], t[Increase(k)]);
        assert Increase(k) == k + 1;
        SafetyDecreasing(t, r, k);
        assert t[r].min &gt;= t[k].min;
        assert t[k+1].min == t[k].min - 1;
        assert t[r].min &gt;= t[k].min &gt; t[k+1].min;
        r := k + 1;
        if t[r].min == 0 { return; }
     }
     else {
        assert !(forall j : nat :: j &gt;= r ==&gt; EnabledDecreaseMin(t[j]));
        ExistsHelperLemma(t, r);
        var k :| k &gt;= r &amp;&amp; !EnabledDecreaseMin(t[k]);
        assert t[k].min &lt;= 0;
        Safety(t, k);
        return;
     }
   }
}</code></pre>
<p>There is alternate way to think about this proof. When does timer will never reach state where <code>min</code> is 0 assuming safety part of spec (<code>Init</code> and <code>Next</code>) ? It is when timer stops working when <code>min</code> is displaying some number greater than 0 - behavior stutters infinitely afterwards. Does our spec include such behavior? In this behavior weakly fair condition allows us to find sequence of states in which <code>min</code> is decreasing to 0. But this is contradiction. Hence such behavior is not statisfied by our Spec.</p>
<p>This is rather silly example to show temporal logic argument - there is no two or more processes/servers competing for fair execution. But I hope this small example which is written in programming language like syntax shows how such argument works.</p>]]></description>
</item>
<item>
<title>Uncovering ghouls using Answer Set Programming</title>
<guid>https://rdivyanshu.github.io/haunted.html</guid>
<description><![CDATA[<p><a href="index.html">↫ Home</a></p>
<h1 id="uncovering-ghouls-using-answer-set-programming">Uncovering ghouls using Answer Set Programming</h1>
<p>Recently I came across this nice puzzle - <a href="https://krazydad.com/haunted/">Haunted</a>. These days my impulse when presented with puzzle is throw Answer Set Programming on it. To get idea of ASP follow <a href="https://rdivyanshu.github.io/asp.html">this blog</a> which solves another puzzle which has somewhat straightforward encoding in ASP.</p>
<p><img src="https://rdivyanshu.github.io/haunted.png" /></p>
<p>A sample puzzle instance and its solution is shown above. In haunted you have to figure out where ghouls (ghosts, zombies and draculas) are hidding in rectangular grid. You can’t directly see ghosts but they are visible in mirrors. Draculas conceal themselves in mirrors but otherwise visible. Zombies have no such powers. You are also given count of each ghoul types and how many of them are visible (counting multiplicity) from boundary locations.</p>
<p>As per tradition, we encode instance and solution separately. First up instance of above puzzle</p>
<pre><code>#const n = 4.

count(0, 1, 0). count(0, 2, 2). count(0, 3, 2). count(0, 4, 3).
count(1, 0, 2). count(2, 0, 1). count(3, 0, 2). count(4, 0, 0).
count(5, 1, 1). count(5, 2, 1). count(5, 3, 1). count(5, 4, 2).
count(1, 5, 1). count(2, 5, 1). count(3, 5, 2). count(4, 5, 1).

mirror(1, 4, &quot;/&quot;).
mirror(2, 1, &quot;\\&quot;). mirror(2, 4, &quot;/&quot;).
mirror(3, 2, &quot;/&quot;). mirror(3, 3, &quot;/&quot;).
mirror(4, 2, &quot;\\&quot;). mirror(4, 3, &quot;\\&quot;).

ghost(2). dracula(4). zombie(3).</code></pre>
<p>We declare size of grid as constant <code>n</code>. <code>count(X, Y, N)</code> encodes relation that from <code>X</code>, <code>Y</code> coordinate <code>N</code> number of ghouls are visible (Grid has been extended to include <code>0</code>th and <code>(n+1)</code>th row and column). <code>mirror(X, Y, T)</code> states the fact that there is mirror of type <code>T</code> at location <code>X</code>, <code>Y</code>. Finally number of each ghoul type is mentioned.</p>
<p>Next general solution as described below. First statement describes our grid. Next 3 statements place ghouls on grid. For example <code>{ ghost(X, Y) : grid(X, Y) } = N :- ghost(N)</code> states that each grid location is valid placement for ghost though solution should only select as many as grid locations as there are ghosts. After this we add constraints that ghouls and mirrors don’t occupy same place as well as two different kind of ghouls.</p>
<pre><code>grid(X, Y) :- X = 1..n, Y = 1..n.

{ ghost(X, Y) : grid(X, Y) } = N :- ghost(N).
{ dracula(X, Y) : grid(X, Y) } = N :- dracula(N).
{ zombie(X, Y) : grid(X, Y) } = N :- zombie(N).

:- ghost(X, Y), mirror(X, Y, T).
:- dracula(X, Y), mirror(X, Y, T).
:- zombie(X, Y), mirror(X, Y, T).
:- ghost(X, Y), dracula(X, Y).
:- ghost(X, Y), zombie(X, Y).
:- dracula(X, Y), zombie(X, Y).

ghost(X, Y, N) :- count(X, Y, TN),
         N = #count { GX, GY, D : mirror_visible(X, Y, GX, GY, D), ghost(GX, GY) }.
dracula(X, Y, N) :- count(X, Y, TN),
         N = #count { DX, DY, D : direct_visible(X, Y, DX, DY, D), dracula(DX, DY) }.
zombie(X, Y, N1 + N2) :- count(X, Y, TN),
         N1 = #count { ZX, ZY, D : mirror_visible(X, Y, ZX, ZY, D), zombie(ZX, ZY) },
         N2 = #count { ZX, ZY, D : direct_visible(X, Y, ZX, ZY, D), zombie(ZX, ZY) }.

:- count(X, Y, N), ghost(X, Y, G), dracula(X, Y, D), zombie(X, Y, Z), N != G + D + Z.

#show ghost/2.
#show dracula/2.
#show zombie/2.</code></pre>
<p><code>ghost(X, Y, N)</code> inscribes that <code>N</code> ghosts are visible from boundary location <code>X</code>, <code>Y</code>. <code>N</code> is equal to number of times we see ghosts in mirrors. Aggregate form <code>#count</code> counts number of elements in a set. In our case elements are tuple <code>GX</code>, <code>GY</code>, <code>D</code> where <code>GX</code>, <code>GY</code> is location of ghost which is visible from <code>X</code>, <code>Y</code>. We need additional direction component <code>D</code> to account for multiple views of same ghoul by mirror reflections. Last component of <code>count/3</code> should be sum of last components of <code>ghost/3</code>, <code>dracula/3</code> and <code>zombie/3</code> as mentioned as constraint. Notice that clingo (ASP implementation we are using) allows us to use same name for relations with different arity. That’s why a relation is mentioned by its name and arity like <code>ghost/2</code> in show directive.</p>
<p>We haven’t defined <code>mirror_visible</code> and <code>direct_visible</code> relations yet. It might be possible to declare such relation in ASP declarative language, but I found it cumbersome to do so and used it as opportunity to learn about clingo python scripting facility documented <a href="https://potassco.org/clingo/python-api/5.6/">here</a>.</p>
<p>We proceed in steps. First let us read instance file, store each statement in an array besides adding it to program we are currently evaluating.</p>
<pre><code>statements = []
clingo.ast.parse_string(
   open(&quot;instance.lp&quot;).read(),
   lambda st: statements.append(st)
)

with clingo.ast.ProgramBuilder(ctl) as b:
   for st in statements:
      b.add(st)</code></pre>
<p>Next we will find location of mirrors in grid by going through each rule and checking if its head starts with <code>mirror</code>. If it is we will store arguments in <code>mirror_loc</code> - its location and type.</p>
<pre><code>mirror_loc = []
for st in statements:
   if st.ast_type != clingo.ast.ASTType.Rule:
      continue
   ast_dict = clingox.ast.ast_to_dict(st)
   if ast_dict[&quot;head&quot;][&quot;atom&quot;][&quot;symbol&quot;][&quot;name&quot;] != &quot;mirror&quot;:
      continue
   arguments = ast_dict[&quot;head&quot;][&quot;atom&quot;][&quot;symbol&quot;][&quot;arguments&quot;]
   arguments = map(lambda x: clingox.ast.dict_to_ast(x), arguments)
   r, c, t = map(lambda x: dict(x.items())[&quot;symbol&quot;], arguments)
   mirror_loc.append(((r.number, c.number), t.string))</code></pre>
<p>For each boundary location we trace path of light as it bounces off through mirrors storing which grid location it arrives at via mirrors and which directly. Then we add appropriate relation - <code>direct_visible</code> or <code>mirror_visible</code>. When finding out mirror location we have to deconstruct clingo AST, here we have to construct clingo AST which is done using <code>build_rule_ast</code> function.</p>
<pre><code>lookouts = itertools.chain.from_iterable(
   [[(0, i), (n+1, i), (i, 0), (i, n+1)] for i in range(1, n+1)])

for i, j in lookouts:
   direct, mirror = visibility(n, i, j, dict(mirror_loc))
   with clingo.ast.ProgramBuilder(ctl) as b:
      for (r, c, d) in direct:
         b.add(build_rule_ast(
                &quot;direct_visible&quot;,
                [clingo.symbol.Number(i), clingo.symbol.Number(j),
                 clingo.symbol.Number(r), clingo.symbol.Number(c),
                 clingo.symbol.String(d)]))
      for (r, c, d) in mirror:
         b.add(build_rule_ast(
                &quot;mirror_visible&quot;,
                [clingo.symbol.Number(i), clingo.symbol.Number(j),
                 clingo.symbol.Number(r), clingo.symbol.Number(c),
                 clingo.symbol.String(d)]))</code></pre>
<p>Let’s finally run our <a href="https://gist.github.com/rdivyanshu/ea7d280767c7c68cffb94f1421813efa">program</a>.</p>
<pre><code># clingo solution.lp

clingo version 5.6.2
Reading from solution.lp
Solving...
Answer: 1
zombie(1,2) zombie(1,3) zombie(4,4) dracula(2,2) dracula(2,3) dracula(3,1) dracula(3,4) ghost(1,1) ghost(4,1)
SATISFIABLE

Models       : 1+
Calls        : 1
Time         : 0.071s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.071s</code></pre>]]></description>
</item>
<item>
<title>Under the hood of Rosette</title>
<guid>https://rdivyanshu.github.io/rosette-internal.html</guid>
<description><![CDATA[<p><a href="index.html">↫ Home</a></p>
<h1 id="under-the-hood-of-rosette">Under the hood of Rosette</h1>
<p>Rosette is a solver-aided language. Its <a href="https://docs.racket-lang.org/rosette-guide/index.html">documentation</a> has good overview of how it can be used. It has been used to <a href="https://github.com/uw-unsat/jitterbug">find bug in eBPF</a>, <a href="https://medium.com/@uwdb/introducing-cosette-527898504bd6">reasoning about SQL equivalence</a> and in <a href="https://emina.github.io/rosette/apps.html">many other ways</a>. I have covered Rosette <a href="https://rdivyanshu.github.io/ma122.html">previously</a> in this blog by using it to solve a puzzle. Rosette is implemented in Racket which has extensive support for building programming languages. In this blog, we will try to peek into how Rosette works through following code.</p>
<pre><code>#lang rosette/safe

(define-symbolic x y integer?)

(define (double x) (+ x x))

(define lst
  (filter even? (list x y)))

(define sol
  (solve (begin (assert (&lt; 0 x))
                (assert (&lt; (double x) y))
                (assert (= 1 (length lst))))))

(when (sat? sol)
  (evaluate (list x y) sol))</code></pre>
<h3 id="syntax">Syntax</h3>
<p>Syntax of Rosette is similar to Racket with additional definitions like <code>define-symbolic</code>, <code>solve</code>, <code>assert</code>, <code>evaluate</code> etc. Creating language which looks like it is breeze in Racket with help of <a href="https://docs.racket-lang.org/guide/syntax_module-reader.html">syntax/module-reader</a>, which Rosette makes use of. Rosette overrides various definitions of Racket to work with symbolic values. Internally these are defined with name identical to their Racket counterpart but prefixed with <code>@</code>. Above code will look like following after removing that masking.</p>
<pre><code>#lang racket

(require rosette/base/adt/list)
(require rosette/base/core/bool)
(require rosette/base/core/numerics)
(require rosette/base/core/real)
(require rosette/base/form/define)
(require rosette/query/form)
(require rosette/query/eval)
(require rosette/solver/solution)

(define-symbolic x y @integer?)

(define (double x) (@+ x x))

(define lst
  (@filter @even? (@list x y)))

(define sol
  (solve (begin (@assert (@&lt; 0 x))
                (@assert (@&lt; (double x) y))
                (@assert (@= 1 (@length lst))))))

(when (sat? sol)
  (evaluate (@list x y) sol))</code></pre>
<h3 id="semantics">Semantics</h3>
<p>Rosette lifts some types (<code>integer?</code>, <code>boolean?</code> etc) so that symbolic constant can be defined for those. Inside Rosette these types (<code>@integer?</code>, <code>@boolean?</code> etc) are represented as <code>struct</code> which holds type specific methods like <code>type-cast</code>, <code>type-name</code> and solver specific methods like <code>solveable-default</code>, <code>solveable-range</code>. Since <code>@integer?</code> is exposed as <code>integer?</code> at surface syntax, it should work as predicate that is <code>(integer? 1)</code> or <code>(integer? x)</code> (<code>x</code> is symbolic integer) should result into true. This is achieved through <a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct-field-index%29%29">struct-index-field</a> which allows <code>struct</code> to be used as function.</p>
<p>To introduce symbolic constant in Rosette <code>define-symbolic</code> macro is used. <code>(define-symbolic x integer?)</code> expands to <code>(define-values (x) ((make-const #'x integer?))</code>. All lifted definitions do as much as concrete evaluation as possible. For example <code>(+ 1 2)</code> evaluates to <code>3</code> whereas <code>(+ 1 x 3)</code> evaluates to <code>(+ 4 x)</code>. Further it reduces symbolic expression in canonical form by sorting subexpressions based on term order. Term order is natural number which accounts for term introduction order in program. In above program term order of <code>x</code> is 0 whereas it is 1 for <code>y</code>, making <code>(+ x y)</code> canonical form of <code>(+ y x)</code>. This makes SMT-Lib encoding small. While generating SMT-Lib Rosette will only output <code>(define-fun e1 () Int (+ 4 c0))</code> (<code>c0</code> is symbolic integer representing <code>x</code> in SMT-Lib) even when surface syntax contains both expressions <code>(+ x 4)</code> and <code>(+ 4 x)</code>. Another way to think about it is reasoning about their equivalence is pushed up at Rosette level instead of pushing down to SMT solvers. This allows Rosette to do some optimizations. For example <code>(if (= (+ x 4) (+ 4 x)) x 4)</code> reduces to <code>x</code> contrast that to naive SMT-Lib encoding which will generate something like following</p>
<pre><code>(declare-fun c0 () Int)
(define-fun e1 () Int (+ c0 4))
(define-fun e2 () Int (+ 4 c0))
(define-fun e3 () Int (ite (= e1 e2) c0 4))</code></pre>
<p>Practically it means SMT-Lib generated by Rosette is easy to read and understand as it strips away various artificial encodings.</p>
<p>In presence of <code>if</code> expression program can branch into different paths depending on predicate. If predicate is concrete value or can be optimized away to it, it is not problem otherwise Rosette uses <code>union</code> to encode it. <code>union</code> is list of predicate and expression pair. In our code <code>lst</code> is a union as <code>filter</code> uses <code>if</code> internally, <code>even?</code> being its predicate. This is how <code>lst union</code> looks like.</p>
<pre><code>&gt;&gt; (union-contents lst)
(list
 (list (&amp;&amp; (= 0 (remainder x 2)) (= 0 (remainder y 2))) x y)
 (list (&amp;&amp; (! (= 0 (remainder x 2))) (! (= 0 (remainder y 2)))))
 (list
  (|| (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2))) 
      (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2)))))
  (ite* (⊢ (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2))) y) 
        (⊢ (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2)))) x))))</code></pre>
<p>In plain english, it is saying that</p>
<ul>
<li>If <code>x</code> and <code>y</code> are both even then <code>lst</code> is <code>(list x y)</code></li>
<li>If <code>x</code> and <code>y</code> are both odd then <code>lst</code> is <code>(list)</code></li>
<li>If <code>x</code> is even and <code>y</code> is odd then <code>lst</code> is <code>(list x)</code></li>
<li>If <code>x</code> is odd and <code>y</code> is even then <code>lst</code> is <code>(list y)</code></li>
</ul>
<p>Rosette maintains that predicates of union are mutually exclusive and union length is within polynomial bound of program size. From user perspective <code>lst</code> is list so they should able to apply list functions on it.</p>
<pre><code>&gt; (union-contents (cons 1 lst))
(list
 (list (&amp;&amp; (= 0 (remainder x 2)) (= 0 (remainder y 2))) 1 x y)
 (list (&amp;&amp; (! (= 0 (remainder x 2))) (! (= 0 (remainder y 2)))) 1)
 (list
  (|| (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2))) 
      (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2)))))
  (ite* (⊢ (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2))) 1 y) 
        (⊢ (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2)))) 1 x))))</code></pre>
<p>Sweet, Rosette goes under each guards (predicates) of <code>union</code> and applies <code>cons</code> to underlying expression. Finally we move to <code>solve</code> part of program. Whenever Rosette sees <code>assert</code> statement it adds corresponding boolean expression in <code>vc</code> parameter. In our program after last <code>assert</code> statement, <code>vc</code> contains following <code>asserts</code> that need to be checked. Since we haven’t used any <code>assume</code> in our program <code>assumes</code> in <code>vc</code> is trivial expression <code>#t</code>.</p>
<pre><code>(&amp;&amp; (&amp;&amp; (|| (&amp;&amp; (= 0 (remainder x 2)) (= 0 (remainder y 2)))
            (&amp;&amp; (! (= 0 (remainder x 2))) (! (= 0 (remainder y 2))))
            (|| (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2)))
                (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2))))))
        (&amp;&amp; (&lt; 0 x) (&lt; (+ x x) y)))
    (= 1 (ite* (⊢ (&amp;&amp; (= 0 (remainder x 2)) (= 0 (remainder y 2))) 2)
               (⊢ (&amp;&amp; (! (= 0 (remainder x 2))) (! (= 0 (remainder y 2)))) 0)
               (⊢ (|| (&amp;&amp; (! (= 0 (remainder x 2))) (= 0 (remainder y 2)))
                      (&amp;&amp; (= 0 (remainder x 2)) (! (= 0 (remainder y 2))))) 1))))</code></pre>
<p>Notice like <code>cons</code> example above, Rosette strips away <code>length</code> function by applying it to expressions of <code>union</code>. Combination of <code>union</code> and concrete evaluation make it possible for Rosette to avoid encoding list and its associated axioms in SMT-Lib. On syntax level, Rosette can handle various ADT like <code>struct</code>, <code>box</code>, <code>vector</code> etc. But when Rosette emits SMT-Lib it only deals with simple data types like <code>Int</code>, <code>Bool</code>, <code>BitVec</code> of SMT-Lib which is possible due to representation of branch using <code>union</code> and enough concrete evaluation of definitions. Inside <code>solve</code>, Rosette encodes <code>vc</code> to SMT-Lib, send it to SMT solver and read result back.</p>]]></description>
</item>
</channel>
</rss>
